#!/usr/bin/perl

use Modern::Perl;
use File::Slurp qw(read_file);
use System::Command;
use Readonly;

Readonly::Scalar my $HYPHEN                  => q{-};
Readonly::Scalar my $COMMA                   => q{,};
Readonly::Scalar my $EMPTY                   => q{};
Readonly::Scalar my $SBATCH_CMD              => q{sbatch};
Readonly::Scalar my $SARRAY_RANGE_REGEXP     => qr{#SARRAY\s+\-\-range\s*=\s*([\d,\s-]+)};
Readonly::Scalar my $SARRAY_JOBNAME_REGEXP   => qr{#SBATCH\s+\-(?:\-job\-name|J)\s*=\s*([[:print:]]+)};
Readonly::Scalar my $SARRAY_JOBNAME_FORMAT   => q{%s[%d]};
Readonly::Scalar my $SARRAY_ENV              => q{SLURM_ARRAYID};
Readonly::Scalar my $SARRAY_DEFAULT_JOB_NAME => q{sarray};

my $batch    = read_file($ARGV[0]);
my @task_ids = get_task_ids($batch);
my $job_name = get_batch_job_name($batch);

foreach my $task_id (@task_ids) {
  my $name = sprintf $SARRAY_JOBNAME_FORMAT, $job_name, $task_id;
  my $cmd  = System::Command->new(
              ($SBATCH_CMD, qq{--job-name=$name}),
              {
                env   => {SLURM_ARRAYID => $task_id},
                input => $batch,
              }
            );

  my $stdout = $cmd->stdout();
  while (<$stdout>) {
    print $_;
  }
  $cmd->close();
}

sub get_task_ids {
  my ($batch_job) = @_;
  my @task_ids    = ();
  my @ids         = ();
  my $tasks       = $EMPTY;

  while ($batch_job =~ m/$SARRAY_RANGE_REGEXP/sg) {
    $tasks = $1;
  }

  if ($tasks =~ /$COMMA/) {
    @ids = split(/$COMMA/, $tasks);
  } else {
    push @ids, $tasks;
  }

  foreach my $id (@ids) {
    if ($id =~ /$HYPHEN/) {
      my ($start,$end) = split(/$HYPHEN/,$id);

      for my $i ($start..$end) {
        push @task_ids, $i;
      }
    } else {
      push @task_ids, $id;
    }
  }

  return @task_ids;
}

sub get_batch_job_name {
  my ($batch_job) = @_;
  my $job_name    = $SARRAY_DEFAULT_JOB_NAME;

  while ($batch_job =~ m/$SARRAY_JOBNAME_REGEXP/sg) {
    $job_name = $1;
  }

  return $job_name;
}

__END__

=head1 NAME

sarray

=head1 SYNOPSIS

  $ sarray batch_file.txt

  Example Batch script:

  #!/bin/bash

  #SBATCH --mail-type=ALL
  #SBATCH --mail-user=user@domain.com
  #SBATCH --job-name=sarray_test
  #SBATCH --time=1-0
  #SARRAY --range=1-10,20-30

  srun testload -t $((${SLURM_ARRAYID} + 60))

=head1 DESCRIPTION

This script is an attempt at providing the array job concept from PBS in SLURM.
You can run multiple jobs from a single batch script with the only difference in
each job being the array index. The array index gives the script a means of changing
parameters, loading differing data files or anything that requires a unique index.

=head1 ARGUMENTS

This script only accepts an batch script suitable for sbatch. The batch script
must include the comment marker to indicate the range of array indexes. The comment
is similiar to sbatch comments that must start in column zero of the script. The value
can be a range seperated by a dash ( - ), a comma seperated list of index numbers or both.

#SARRAY --range=1-20

or

#SARRAY --range=1-10,12,14,16-20

This would create jobs with the id appended to the end of your defined job name with the id
within brakets such as; jobname[1], jobname[2] ... jobname[20].

The array index is passed back to the batch script as the environment variable $SLURM_ARRAYID for
each iteration through the index(es) you provided via the --range option.

=head1 AUTHOR

Chris Scheller <schelcj@umich.edu>

=head1 COPYRIGHT

Copyright (C) 2011, all rights reserved by University of Michigan

=head1 TODO

=over

=item * validate batch file passed on commandline

=item * test regexps aren't to greedy

=back
